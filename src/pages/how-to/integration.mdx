---
layout: '@layouts/BaseLayout.astro'
title: NGINX Integration
---
# NGINX Integration

Unit is a potent and versatile server in its own right.  However, if you’re used to NGINX’s rich feature set, you can deploy it in front of Unit; one notable use case for NGINX here is securing the Unit control socket.

## Fronting Unit with NGINX

Configure a [listener](../configuration.md#configuration-listeners) in Unit:

<Code_Block language="json" hints={[{ number: "1", display_text: "127.0.0.1:8080", tooltip: "Socket address where NGINX proxies requests", nxt_type: "nxt_ph" }, { number: "2", display_text: "...", tooltip: "Unit's internal request destination", nxt_type: "nxt_ph" }, { number: "3", display_text: "X-Forwarded-For", tooltip: "The header field set by NGINX", nxt_type: "nxt_hint" }, { number: "4", display_text: "127.0.0.1", tooltip: "The IP address where NGINX runs", nxt_type: "nxt_ph" }]}>{`{
    "NXT1": {
        "pass": "NXT2",
        "forwarded": {
            "client_ip": "NXT3",
            "source": [
                "NXT4"
            ]
        }
    }
}`}</Code_Block>

Here, **forwarded** is optional; it enables identifying the [originating IPs](../configuration.md#configuration-listeners-xff) of requests proxied from **source**.

In NGINX configuration, create an upstream in the **http** context, adding the listener’s socket as a **server**:

<Code_Block language="nginx" hints={[{ number: "1", display_text: "127.0.0.1:8080", tooltip: "Unit's listener socket address", nxt_type: "nxt_ph" }, { number: "2", display_text: "/unit/", tooltip: "Arbitrary location", nxt_type: "nxt_hint" }, { number: "3", display_text: "X-Forwarded-For", tooltip: "Unit's listener must list the same name in client_ip/header", nxt_type: "nxt_hint" }]}>{`http {
    upstream unit_backend {
        server NXT1;
    }

    server {
        location NXT2 {
            proxy_pass http://unit_backend;
            proxy_set_header Host $host;
            proxy_set_header NXT3 $proxy_add_x_forwarded_for;
        }
    }
}`}</Code_Block>

A more compact alternative would be a direct **proxy\_pass** in your **location**:

<Code_Block language="nginx" hints={[{ number: "1", display_text: "/unit/", tooltip: "Arbitrary location", nxt_type: "nxt_hint" }, { number: "2", display_text: "127.0.0.1:8080", tooltip: "Unit's listener socket address", nxt_type: "nxt_ph" }, { number: "3", display_text: "X-Forwarded-For", tooltip: "Unit's listener must list the same name in client_ip/header", nxt_type: "nxt_hint" }]}>{`http {
    server {
        location NXT1 {
            proxy_pass http://NXT2;
            proxy_set_header Host $host;
            proxy_set_header NXT3 $proxy_add_x_forwarded_for;
        }
    }
}`}</Code_Block>

The **proxy\_set\_header X-Forwarded-For** directives work together with the listener’s **client\_ip** option.

For details, see the [NGINX documentation](https://nginx.org).  Commercial support and advanced features are [also available](https://www.nginx.com).

## Securely Proxying Unit’s Control API

By default, Unit exposes its [control API](../controlapi.md#configuration-mgmt) via a UNIX domain socket.  These sockets aren’t network accessible, so the API is local only.  To enable secure remote access, you can use NGINX as a reverse proxy.

<Note type="warning">
Avoid exposing an unprotected control socket to public networks. Use NGINX or a different solution such as SSH for security and authentication.
</Note>

Use this configuration template for NGINX (replace placeholders in **ssl\_certificate**, **ssl\_certificate\_key**, **ssl\_client\_certificate**, **allow**, **auth\_basic\_user\_file**, and **proxy\_pass** with real values):

<Code_Block language="nginx" hints={[{ number: "1", display_text: "/path/to/ssl/cert.pem", tooltip: "Path to your PEM file; use a real path in your configuration", nxt_type: "nxt_ph" }, { number: "2", display_text: "/path/to/ssl/cert.key", tooltip: "Path to your key file; use a real path in your configuration", nxt_type: "nxt_ph" }, { number: "3", display_text: "/path/to/ca.pem", tooltip: "Path to certification authority PEM file; use a real path in your configuration", nxt_type: "nxt_ph" }, { number: "4", display_text: "1.2.3.4", tooltip: "Replicate and update as needed with allowed IPs and network CIDRs", nxt_type: "nxt_ph" }, { number: "5", display_text: "/path/to/htpasswd", tooltip: "Path to your htpasswd file", nxt_type: "nxt_ph" }, { number: "6", display_text: "/path/to/control.unit.sock", tooltip: "Path to Unit's control socket", nxt_type: "nxt_ph" }]}>{`server {

    # Configure SSL encryption
    listen 443 ssl;

    ssl_certificate NXT1;
    ssl_certificate_key NXT2;

    # SSL client certificate validation
    ssl_client_certificate NXT3;
    ssl_verify_client on;

    # Network ACLs
    allow NXT4;
    deny all;

    # HTTP Basic authentication
    auth_basic on;
    auth_basic_user_file NXT5;

    location / {
        proxy_pass http://unix:NXT6;
    }
}`}</Code_Block>

The same approach works for an IP-based control socket:

```nginx
location / {
    proxy_pass http://:nxt_ph:`127.0.0.1:8080 <Unit's control socket address>`;
}
```